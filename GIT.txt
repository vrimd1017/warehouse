#OpenTutorials.org __Git 정리
//https://opentutorials.org/module/3746/22490
__모든 종류의 문서를 관리/자주변경/변경이력관리/백업/공동작업을 위함.

//https://opentutorials.org/course/1492
버전관리 시스템은 소스코드의 중요한 변화들을 기록하는 행위.
어떤 문제가 발생했을 때, 문제의 맥락을 파악 할 수 있도록 도와주고, 변화에 실패 했을 때 과거의 상태로 쉽게 돌아가기 위함.
--> 결과적으로 실패에 대한 부담이 줄어들음.
--> 버전관리는 백업, 협업과 같은 장점을 제공함.
깃의 기본적인 사용법은 명령어를 이용한 것.
이는 좀 어렵게 느껴질 수 있기때문에 GUI기반의 SourceTree를 사용.

//https://backlog.com/git-tutorial/kr/
__입문편
이전상태로 문서를 돌이키기 가장 쉬운 방법은, 해당 문서를 미리 복사해 두는 것.
--> 가장 단순하지만 매번 복사하는 일은 번거롭고 실수 할 가능성도 많음. 이름이 불규칙적이면 최신을 파악하기도 힘이 듦.
공유문서에 대한 작업을 하면 서 해당 파일을 동시에 편집한다면, 다른 사람의 작업내용을 지워버릴 가능성도 있음.
==> Git과같은 버전 관리 시스템이 필요로 하게 됨.
Git이란 소스코드를 효과적으로 관리하기 위해서 개발된 '분산형 버전 관리 시스템'
변경된 이력을 쉽게 확인할 수 있고, 특정 시점에 저장된 버전과 비교하거나 특정 시점으로 돌아가는게 가능함.
또한 공유 문서의 편집시에, 다른 사람의 편집 내용과 출돌이 일어난다면 경고가 발생됨.

Git Repository란, 변경 이력 별로 구분하여 파일이나 폴더를 저장해 놓는 곳.
두 종류가 존재함.
1) 원격 저장소(Remote Repository)
:: 원격 저장소 전용 서버에서 파일이 관리되며, 여러 사람이 함께 공유하기 위한 장소
2) 로컬 저장소(Local Repository)
:: 내 PC에 파일이 저장되는, 개인 전용 저장소.

평소에는 로컬 저장소에서 작업하다가 필요시에 원격 저장소로 업로드 하거나,
원격 저장소에서 다른 사람이 작업한 파일을 로컬 저장소로 가져와 사용 할 수 있음.

로컬저장소는 아예 새로 만들거나, 이미 만들어져있는 원격 저장소를 복사하여 사용이 가능함.

커밋(Commit)
파일 및 폴더의 추가/변경사항을 저장소에 기록하는 것.

//이어서

Commit :: 변경이력이 기록되고 시간순으로 저장됨. 즉, 거슬러가면 변경 이력과 내용을 알 수 있게됨.
+ 각 Commit에는 40자리 고유 이름이 붙으며, 저장소는 이를 통해 각 Commit을 구분/선택.
Commit은 이력을 남기는 중요한 작업이므로, 커밋시에는 커밋메시지를 필수로 입력해야 함.
Commit메시지가 없다면 커밋이 실행되지 않음.

__작업 트리(Work Tree)와 인덱스(Index)
Git에서는 폴더를 Work Tree라고함.
이때, 커밋을 실행하기 전의 저장소와 작업 트리 사이에 존재하는 공간은 '인덱스'라고 함.
변경된 파일이 Commit되기 위해서는 변경/수정된 파일이 인덱스에 있어야 한다.
여러개의 파일을 수정했을 경우에, 그리고 그 중에서 몇 개만 저장소에 등록 하고싶을 때,
작업트리에안에 커밋하고자 하는 파일을 선택하여 일부만 인덱스(라는 가상공간에) 등록하여 커밋시킬 수 있음.
이때, 작업트리에서 선택하는 작업을 '인덱스에 등록' 혹은 '스테이징(stage)'이라고 표현 함.
인덱스를 통해 원하는 일부 변경사항만을 커밋이 가능해짐.

# Git은 명령어로 alias(별칭) --> 단축키를 설정할 수 있음.
:: git config --global alias.co checkout
=> --global 명령어는 전역설정에 대한 옵션이며, 현재 프로젝트에만 적용할때는 주지 않음.
=> 위의 명령어는 전역설정에서 별칭으로 'co'를 상용하며 이는 checkout에 대한 단축어로 사용.

+ windows콘솔에서 파일명에 한국어를 사용할 시 '\346\226\260\...'과 같은 형식으로 표시됨.
   " git config --global core.quotepath off "를 통해 파일명이 올바르게 표시될 수 있도록 할 수 있음.
+ windows콘솔에서는 한국어를 입력할 수 없기 때문에 커밋 메시지에서 한국어를 표시하고자 한다면 
   ' -m '옵션 대신에 외부 에디터를 사용 해야 함.
   이때, 해당 에디터는 문자 코드 'UTF-8', 라인피드 코드 'LF'와 호환되어야 함.
   " git config --global core.editor "\"[사용할 에디터의 경로]\"" " ...
   아, -m옵션이 뭐지.
   // m옵션이란????????????????

+  // sshfs란????????????

@@ git init시에 오류 발생 시 관리자 권한으로 실행 할 것. 
@@ git init할 때에 permiossion denied떳을때 이야기임.

git init
mkdir tutorial
cd tutorial
git init	
이걸 입력한건데.. 음.. git init은 출입 느낌인가.... mkdir, cd.

" git status " 명령어를 통해서 git관리하의 작업트리와 인덱스 상태 확인이 가능함.
tutorial 작업트리에 파일을 하나 생성 후에 git status를 입력할 경우 상태 확인이 가능함.
간단하게 해당 파일의 이름이 나옴.
안에 폴더가 추가된다면 어떻게 표시되나 싶어서 git/1111, git/1111/2222, git/1111/2222/3333을 추가해봄.
이 경우에 git디렉터리에서 git status한 경우에 디렉터리에 관한 내용이 보이지 않았음.
이후 cd 1111을 한 후에 git status를 한다면 추가한 파일(ex. sample.txt)의 내용이 ../sample.txt가 됨.
어...그랬는데...
git init을 입력하고 다시 git status하니까 디렉터리의 명이 나옴.
인덱스에 등록하지 않았기 때문에 Untracke file로 뜨기는 하는데...
이제서야 디렉터리가 표시되는 이유는 git init의 차이때문인듯.
그러네, 즉석에서 mkdir로 폴더를 생성하고 ls했을 때 해당 폴더가 확인은 되는데
즉석에서 git status했을 때 표시가 안됨.
git 정보에 등록이 안되어있는건가

Untracked files --> 해당 파일이 이력 추적 대상이 되지 않음. 
이 파일들은 처음 한번만 인덱스에 등록되면 자동으로 추적 대상에 등록할 수 있음.
음.. 느낌상 인덱스에 등록되면 자동으로 추적 대상에 등록되기는 하지만,
따로 인덱스는 아니더라도 추적 대상에 등록할 수는 있을거같긴한데
아닌가..

Commit.
git add sample.txt와 같은 명령어 입력시에 인덱스에 해당 파일이 추가가 됨.
git commit -m "<comment>" 와 같이 입력 할 경우엔 모든 변경사항이 커밋됨.

아, 이게 git status 할 경우 untracked file의 경우에는 인덱스에 등록되지 않은 파일을.
변경/수정된 파일의 경우에는 changes to be committed: 에 등록됨.
이때 git commit -m "<comment>"할 경우에 커밋됨.
이후 git status를 할 경우에는 기존에 changes to be committed:에 있던 파일이 사라지게 됨.
결론적으로 변경사항만 보여준 것. ls와 같이 리스트를 보여주는 개념이 애초에 아니였음.

저장소의 변경 이력을 확인하기 위해서는 log 명령어를 사용하여 확인한다.
git log
이때, gui로 확인하고싶다면 "gitk"를 입력하면 gui버전으로 저장소의 변경 이력을 확인 가능함.

push.
내 PC의 로컬 저장소에서 변경된 이력을 원격 저장소에 공유하는 것. 업로드.
:: 웹 상의 원격 저장소로 변경된 파일을 업로드 하는 것.
push를 하게되면 원격 저장소에 내 변경 이력이 업로드되며, 원격 저장소와 로컬 저장소가 동일한 상태가 됨.

clone.
다른사람의 변경이력이 적용된 원격 저장소가 있다면, 이걸 웹에서 통째로 복제해 내 PC에 직접 작업할 수 있음.
clone이란, 원격 저장소를 복제하는 것.
즉, 원격 저장소의 이력내용. 즉 그 변경된 내용을 다른 PC에서 로컬 저장소로 사용할 수 있게 되는 것.

pull.
문서를 공유해서 여러 사람이 함께 작업을 하기 시작하면, 모두가 같은 원격저장소에 자신이 한 작업 결과를 푸시(push)하게 됨.
그렇다면 내가 작업하기에 앞서, 다른 사람이 원격 저장소에 올려놓은(push한) 변경 내용을 내 로컬 저장소에 적용(pull)할 필요가 있음.
:: 원격 저장소의 문서를 로컬 저장소로 업데이트 하는 것.
pull시에는 원격 저장소의 최신 변경 이력을 다운로드하여 로컬 저장소에 내용을 적용 함.

// git log 시에 HEAD -> master라는 표시가 있는데 이게 머지

Backlog
원격저장소로 Backlog라는걸 사용하는데 음...
이게 뭔지에 대한 자세한 설명은 없네
Backlog에는 관리자 권한이 있는 사용자만 Git저장소를 만들 수 있으며,
권한이 없다면 관리자 권한을 가지고 있는 사람에게 저장소 생성을 요청해야하고...또는 무료 계정필요.
가상으로 사용하도록 한, 클라우드 서버인거같은데...
나중에 되며 aws나 따로 서버 컴퓨터를 둬서 사용이 가능할듯?
일단 있는대로 Backlog를 사용한다고 하면..
git에 관련된 내용은 아닌거 같아서 일단 뺏는데 음.. http는 됬고.. ssh는 key등록이 필요한거 같은데 음.. 하려나

이어서 push.
원격 저장소의 이름은 다른 이름으로 기록해 둘 수 있음.
이게 alias와는 좀 다른 내용인거같기도?
일단 git에 원격 저장소를 추가. 정확히는 등록인거같은데, 어쨋든 이를 추가하기 위해선 remote명령어를 사용함. 
git remote add <name><url> 의 형식으로 등록함.
name은 등록할 이름. url은 등록할 원격 저장소의 url.
git remote add testrepo https://backlog-sj.backlog.com/git/TESTPROJECT_BACKLOG_SJ/tutorial.git 로 등록했음 일단..
오우... 이때 임으로 testrepo라는 이름을 사용했는데 origin이라는 이름을 사용했네
이게 이유가 있었던게, 콘솔의 경우에 push / pull시에 원격 저장소명을 생략하게 된다면
origin이라는 이름의 원격 저장소를 자동으로 사용하게 됨.

remote를 통해 원격 저장소의 이름을 등록했다면 push시킬 차례
git push <repository> <refspec>... 의 꼴로 사용함.
repository는 push할 경로의 주소, refspec은 push할 브랜치를 지정함.
$  git push -u origin master
실행 옵션에서 한번 -u를 지정하면, 이후에는 해당 브랜치명 지정을 생략할 수 있음.
+ 비어있는 원격 저장소에 최초로 push했을 때는 원격 저장소명과 브랜치명을 생략할 수 없음.

git폴더에서 최초에 tutorial폴더를 생성했었는데
이게 git remote add하는게 폴더(?)기준인가?
git폴더에서 remote로 origin등록한것과 tutorial폴더에서 origin등록한게 다르다고 해야되나
이전에 git폴더에서 origin등록한게 적용이 안되네
+ 한번 틀린건지 Unauthorized라는데 음.... 다시 사용자 이름과 비밀번호 입력하라 뜨질 않네

<>remote: unauthentication. fatal : authentication failed ~~~
음.. 뭔가 그게 안되네 
같은 에러인줄 알았는데 아니긴햇음.ㅇㅇ
해당 리모트를 삭제하고 다시 등록하라고 되어 있었고..
$ git remote -v 
명령어 입력 시 현재 등록된 리모트에 대한 정보가 출력 됨.
이후 
$ git remote remove <remote명> // 여기서는 git remote remove origin
으로 하여 origin이라는 이름의 remote를 삭제함. 다시 등록하면 된다는데 안되네 음.

ㅇ미낭러;민아ㅓㄹ;ㅣㄴㅁㅇ
Backlog에서 SSH Registry등록하라고해서 ssh key generator에서 ssh등록하고
이거 다시 Backlog에 등록해줬는데... 왜 또 안될까
https://git-scm.com/book/ko/v2/Git-%EC%84%9C%EB%B2%84-SSH-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0

아 안되던거 어떻게든 되게 했네
$ git remote -v			//확인
$ git remote remove origin
$ git remote add origin backlog~~~	// 기존 https기반 remote를 SSH기반으로 변경/등록.
$ git push -u origin master

$ git push -u origin master
The authenticity of host 'backlog-sj.git.backlog.com (35.166.55.243)' can't be established.
RSA key fingerprint is SHA256:w1Lng4UpfjBOloZubOkoIusr/eYXc6lBfxcaLlogfI0.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added 'backlog-sj.git.backlog.com,35.166.55.243' (RSA) to the list of known hosts.
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Writing objects: 100% (3/3), 249 bytes | 249.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)

아 자체 그게 있던데 자체 user...pwd...

To backlog-sj.git.backlog.com:/TESTPROJECT_BACKLOG_SJ/tutorial.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.

이후 backlog에서 tutorial first commit이라는.. 메세지를 가진 commit이 확인 가능함.

음 머지 근데 저장소 파일에 확인이 안되네

파일수정.
$ git status
변경된 파일 붉은색 modified: 로 표시됨.(새 파일이 new file이였던것과는 다름.)
$ git add prac_sample샘플.txt
해당 파일이 녹색 modified:로 인덱스에 추가되었음이 표시됨.
$ git commit -m "message"
인덱스에 올라온 변경사항을 커밋.

아 뭐지 이번엔
$ git log 로 확인해보면 message로도 second commit이 올라가 있는데
왜 backlog에서 직접 확인해보면 뭐 commit사항도 안올라가있고
파일도 안올라가있고
에헤헤헤ㅔ에ㅔ헤헤에헤 멀까나ㅏ아ㅓ린

일단, 지금까지 git console에서는 git log시에 커밋이력이 남는데
저장소에서는 이력이 안떳던 이유가
push를 안해줬기 때문...
git log의 이력은 commit이력임.
저장소로 직접 업로드 하는것은 push. 헷갈리지말것.

일단은 backlog를 쓰지 않기로 결정.
내용만 추가로 작성.

Clone.
clone명령어는 원격 저장소의 파일을 로컬 저장소에 복사해 오는 작업.
$ git clone <repository> <directory>
<repository>에는 원격 저장소의 URL을, <directory>에는 복제대상의 폴더명을 지정.
ex) $ git clone https://monkey.backlogtool.com/git/BLG/tutorial.git tutorial2
이러면 원격 저장소의 username과 password 지정.

어..복제한 저장소에 다시 push 할 때에는
기존에 push시에
git add <파일명>
git commit -m <message>
git push -u <url> <branch명> 사용.
이때, 복제한 저장소로 다시 push하는 경우에는 뒤의 파라미터를 제외하고 $git push

이어서 pull.
원격 저장소의 내용을 로컬 저장소로 가져오는 것. 
$ git pull <repository> <refspec>... 의 꼴.
저장소명 <repository>가 생략되면 origin의 이름으로 pull을 수행함.
 
병합(merge)
원격 저장소에 파일을 push하고자 할 때, 즉, 내가 pull을 실행한 후 다른 사람이 먼저 push를 하고 
이후에 내가 push요청을 할 때에 내 요청은 거부됨.
병합하는 과정을 통해서 다른 사람의 업데이트 이력을 내 저장소에도 갱신해야함
병합하지 않은채로 push가 될 경우 다른사람이 push한 내역이 사라져버리기 때문임.
기본적으로는 git이 현재 브랜치에 알아서 변경사항을 통합해줌.
이때, git이 자동으로 통합할 수 없는 경우가 있으며, 이 경우는 원격 저장소와 로컬 저장소 양쪽에서 파일의 동일한 부분을 변경한 경우에 자동으로 통합이 안됨.
--> 두가지 변경 내용 중 어떤 내용을 저장할 것인지 판단이 안되기 때문임.
변경 내역에서 ============로 구분되며,
=======의 윗부분이 로컬 저장소, 아랫 부분이 원격 저장소임.
변경된 부분을 제대로 수정하여 커밋을 수행하면 됨.
병합의 경우에, 콘솔에서 역시 마찬가지로 merge에 대하여 충돌이 발생한 파일을 열게되면 ===========으로 구분되어있음.
불필요한 행을 삭제하고, 인덱스에 올리고, 커밋하고, 푸시하면 업데이트가 가능.

브랜치(Branch)
Git을통해 소스코드를 공유하고 개발하는 경우에는, 각 개발자마다 누군가는 버그를 수정하고 누군가는 새로운 기능을 추가 하는 등, 동일한 소스코드를 기반으로 서로 다른 작업을 하는 경우가 많음.
이 경우엔 각각 다른 버전의 코드가 만들어짐.
이때, 파일을 공유하는 여러 사람이 동시에 다양한 작업을 할 수 있게 만들어주는 기능을 브랜치(Branch)라고 함.
각자의 독립적인 저장소에서 동시에 소스코드를 변경하고, 분리된 작업 영역에서 변경된 내용을 나중에 원래의 버전과 비교하여 하나의 새로운 버전으로 만들어 내는 작업을 할 수 있음.

독립적으로 어떤 작업을 진행하기 위한 개념으로, 각각의 브랜치는 다른 브랜치의 영향을 받지않기때문에 여러 작업을 동시에 진행 할 수 있게됨.
독립적으로 작업된 각각의 브랜치들은 다른 브랜치와 병합(merge)하여, 새로운 하나의 브랜치로 만들 수 있음.
동시 작업을 할 때에, 다른 사람의 작업에 영향을 주거나 받지 않도록 하기 위해서 메인 브랜치에 자신의 작업 전용 브랜치를 만듬.
작업이 끝난 사람은 메인 브랜치에 자신의 변경 사항을 적용.
작업자들은 다른 작업에 영향을 받지 않고, 독립적으로 특정 작업을 수행, 하나의 결과로 모아감.
이런 방식으로 '작업 단위' 즉, 브랜치로 작업할 경우 중간 중간 기록이 남게 됨. 
기록이 남게 되면, 문제가 발생했을 때 원인이 되는 작업을 찾아내거나 그에 따른 대책을 세우기 쉬워짐.

저장소 생성 
--> 'master'라는 이름의 브랜치가 생성됨.
새로운 파일을 생성, 저장(commit)등의 작업은 모두 'master' 브랜치를 통해 처리됨.
새로운 브랜치를 만들어서 이제 이를 사용한다고 선언하지 않는 이상 모든 작업은 branch에서 이루어짐.
브랜치를 효과적으로 관리하기 위해서는, 작업할 팀원과 어떠한 방식으로 브랜치를 만들고 통합할 것인지 미리 정하는게 좋음.
ex) 이름규칙, 어떤 상황에 브랜치를 만들지, 어느 시점에 통합(merge)시킬지 등등.
1_ 통합 브랜치(Integration Branch)
--> 언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치.
--> 늘 안정적인 상태를 유지해야 함. 모든 기능이 정상적으로 동작하는 상태.
보통은 통합 브랜치에서 문제발생 혹은 새로운 기능추가가 필요할 때 토픽 브랜치를 만들어냄.
일반적으로는 master브랜치를 통합브랜치로 사용함.
2_ 토픽 브랜치(Topic Branch)	//피처 브랜치(Feature branch)
--> 기능 추가, 버그 수정과 같은 단위 작업을 위한 브랜치.
여러개의 작업을 동시에 진행할 때에는 그 수만크 토픽 브랜치를 생성하여 사용함.
보통 통합브랜치로부터 만들어내며, 단위 작업이 종료되면 다시 통합 브랜치로 병합하여 사용함.

브랜치 전환.
Git에서는 항상 작업할 브랜치를 미리 선택해야 함.
기본적으로는 master브랜치가 선택되어있음.
다른 브랜치에서 작업하고 싶을 때에는, 체크아웃(checkout)명령어를 실행해 브랜치를 전환함.
체크아웃을 실행하면, 해당 브랜치의 마지막 커밋내용이 작업 트리에 펼쳐짐.
이후 실행한 커밋은 해당 브랜치에 추가되게 됨.
음.... 작업트리에 펼쳐진다는게... 어떤거지...
선택된 브랜치에 커밋내용을 push시킬때, 해당 브런치로 push된다는 내용인거같은데...
아
음...push까지는 이해가 되는데
체크아웃을 했는데 마지막 커밋내용이 작업 트리에 펼쳐진다는게
그냥 커밋내용을 로컬로 pull한다는 의미인가?
이부분은 좀 실제로 해봐야될듯

HEAD
현재 사용중인 브랜치의 선두 부분을 나타냄.
기본적으로 master브랜치를 사용하니, 기본적으로는 master브랜치의 선두 부분을 나타냄.
HEAD를 이동하면 사용하는 브랜치가 변경됨.

커밋을 지정할 때, ~(틸트, 물결기호)와 ^(캐럿, 삽입기호)을 사용하여 현재 커밋으로부터 특정 커밋의 위치를 가리킬 수 있음.
~(틸드)와 숫자를 HEAD뒤에 붙여 몇세대 앞의 커밋을 가리킨다던지,
^(캐럿)으로 브랜치 병합에서 원본이 여럿 있는 경우 몇번째 원본인지를 지정한다거나 할 수 있음.
틸드는 약간 직관적인데 캐럿은 아니네 음 좀 나중에 다시 봐야하나

stash
파일의 변경 내용을 일시적으로 기록해 두는 영역.
작업트리와 인덱스 내에서 아직 커밋하지 않은 변경을 일시적으로 stash에 저장해 둘 수 있음.
stash에 저장된 변경 내용은 나중에 원래의 브랜치나 다른 브랜치에 커밋할 수 있음.

커밋하지 않은 변경 내용이나 새롭게 추가한 파일이 인덱스와 작업 트리에 남아 있는 채로 다른 브랜치로 전환(checkout)하면, 그 변경 내용은 기존 브랜치가 아닌, 전환된 브랜치에서 커밋이 가능함.
음... 작업트리에 대한 개념이 우선인가...일단 전체적으로 현재 수정/변경/생성된 결과를 git의 어느 브랜치에 올릴것인지. 이때, 변경을 commit하지 않을때 다른 브랜치로 checkout시에, 그리고 다른 브랜치로 다시 checkout시에, 한번 전환된 브랜치에서 수정/변경이 일어났을 경우 checkout되지 않을 수 있음.
이전 커밋하지 않은 변경 내역을 커밋하거나, stash를 이용해 일시적으로 변경 내용을 다른 곳에 저장하여 충돌을 피하게 한뒤 checkout해야함.

stash에 일시저장하는 내용은 뭔가 제대로 안나와있네 다른부분을 참고해야할듯.

merge.
토픽브랜치의 단위작업이 끝나며 통합브랜치로 병합하는 작업을 거치게 됨.
브랜치 통합에는 merge를 사용하는 방법과 rebase를 사용하는 방법이 있음.
방법에 따라서 통합 후의 브랜치의 이력이 크게 달라짐.
빨리감기(fast-forward)병합. 토픽 브랜치가 다시 병합될때, 마스터브랜치의 이력이 변경 없을경우.
이 경우에는 그냥 그대로 병합시키면 됨. 이력을 이동시키기만 하면 되므로.
기존에 마스터브랜치에 여러가지 변경 사항이 경우도 있으며, 이 경우에는 마스터브랜치와 토픽브랜치의 변경 내용을 하나로 통합할 필요가 있음.
이런 경우에는 병합 커밋(merge commit)을 실행하게되며, 통합 브랜치로 통합된 이력이 생기게 됨.
fast-forward병합이 가능한 경우라도, 이러한 병합방법을 사용하지 않도록 만들수도 있음.
fast-forward병합의 경우에는 마스터브랜치의 병합이력이 그대로 토픽 브랜치의 이력을 따라감.
non fast-forward병합의 경우에는 각각의 브랜치들의 기존 이력은 유지하면서 병합커밋된 이력이 각각 브랜치의 이력에 추가됨.
non fast-forward의 경우에는 실행한 작업 확인 및 브랜치 관려 면에서 더 유용할 수 있음.

rebase.
rebase방법을 사용하게되면 병합하고자했던 토픽브랜치의 이력이 마스터브랜치의 이력 뒤로 이동하게됨. 즉, 두개의 브랜치가 통합되면서 이력이 하나로 통합되게 됨.
이때, 이전에 마스터브랜치의 수정내용과 커밋된 버전들이 토픽브랜치의 수정된 부분과 충돌될 수도있음.
이때에는 각각의 커밋에서 발생한 충돌 내용을 수정할 필요가 있음.
rebase시에는 마스터브랜치의 이력뒤에 토픽 브랜치의 이력이 이어서 추가가 됨.
하지만, 이때 master의 위치는 그대로있으며, 이 상태에서 해당 토픽 브랜치를 fast-foward병합한다면
master의 위치가 변경됨. 

merge/rebase
merge 	:: 변경 내용의 이력이 모두 그대로 남아있음. 이력이 복잡해짐.
rebase	:: 이력은 단순해지지만 원래의 커밋 이력이 변경됨. 정확한 이력을 남겨야할 필요가 있을 경우에는 사용해서는 안됨. 

https://backlog.com/git-tutorial/kr/stepup/stepup1_5.html
어떻게 사용하는지의 느낌이랄까
마스터가있고... 브랜치가 두갠데 하나는 버그픽스, 하나는 기능추가용일때 
결론적으로 어떻게 뭐 추가한다던가...하는내용의 흐름이랄까...

+ 크게 4가지 브랜치로 나누어 사용
1) 메인 브랜치(Main Branch)
2) 토픽 브랜치(Topic Branch) // 피처 브랜치(Feature Branch)
3) 릴리스 브랜치(Release Branch)
4) 핫픽스 브랜치(Hotfix Branch)

https://nvie.com/posts/a-successful-git-branching-model/

1) 메인 브랜치
- master	:: 배포 가능한 상태만을 관리. 커밋할 때에는 태그를 사용하여 배포 번호를 기록함.
- develop	:: 통합 브랜치의 역할. 평소에는 이 브랜치를 기반으로 개발을 진행함.
2) 피처 브랜치
- 토픽 브랜치의 역할.
- 수정/변경/기능추가등의 이슈가 발생할 때 develop으로부터 분기하여 사용함.
- 단위작업이기때문에 공유할 필요가 없으며, 완료시 develop브랜치로 병합하여 공유.
3) 릴리즈 브랜치
- 수정, 기능추가가 완료된 상태로 모든 기능이 정상적으로 동작하는지를 확인.
- 관례적으로 브랜치 이름앞에 release-를 붙임.
- 다음번 릴리즈를 위한 개발 작업은 develop브랜치에서 계속 진행.
- 릴리즈 브랜치에서는 릴리즈를 위한 최종적인 버그 수정 등의 개발을 수행. 
- 모든 준비이후에 배포 가능한 상태가 되면 master로 병합. 병합한 커밋에 릴리즈 번호 태그를 추가.
- 릴리즈 브랜치에서 점검하면서 발견한 버그 수정사항은 develop브랜치에도 적용해줘야함.
4) 핫픽스 브랜치
- 배포한 버전에 긴급히 수정을 해야 할 필요가 있을 대, master브랜치에서 분기하는 브랜치.
- 관례적으로 브랜치 이름앞에 hotfix-를 붙임.
- 배포한 소스코드에 큰 버그가 발생하여 문제가 되는 부분을 빠르게 수정해서 안정적으로 다시 배포해야 하는 상황.
- 수정후엔 develop브랜치에 병합.... develop병합부분은 이해가 잘 안가긴 하네.

이게, 음.. 브랜치를 나눠서 관리한다는게 확실히 뭔가 개발과정의 버전을 관리하는 느낌이 들긴 하네.

=======================================================

GitHub.
소스코드 관리 서비스. 소스코드 열람, 버그관리, SNS기능등을 가지고있음.
Commit		:: 파일을 추가하거나 변경 내용을 저장소에 저장하는 작업.
Push		:: 파일을 추가하거나 변경 내용을 원격 저장소에 업로드하는 작업.
Branch
현재 버전의 유지 보수를 하면서 새로운 기능 추가 및 버그 수정을 위한 버전관리기능.
흐름을 분기하여 기록하는 것을 의미함.
분기의 한 지점은 다른 지점의 영향을 받지 않기때문에 같은 저장소에서 각 개발을 해 나갈 수 있음.
동시에 이루어지는 여러 버전 관리를 할 수 있는 구조.

Branch병합
실제 개발 현장에서는 '새로운 기능'의 브랜치를 만들고 개발하고, 테스트가 완료되면 메인 master브랜치에 통합이라는 흐름으로 개발 작업을 수행함.



- 로컬저장소 파일 작성
- git add. 인덱스에 파일 추가
- git commit. 변경결과를 로컬 저장소에 커밋

mkdir
cd
ls
pwd
history
git init			:: Git저장소를 새로 만드는 명령. 현재 디렉토리를 Git저장소로 변환.
git add 'filename'		:: 해당 파일/디렉토리를 커밋하기 위해서 인덱스에 추가
			:: 와일드카드를 통해 여러 대상을 지정할수도 있음.
git commit -m "msg"	:: 커밋시키고자 인덱스에 등록한 변경사항을 commit.
			:: 옵션을 지정하지 않으면 커밋 메시지를 작성하는 편집기를 시작.
			:: -a옵션은 변경된 파일을 검색하고, 인덱스에 추가하는 작업도 실시.
			:: commit HEAD가 가리키는 브런치에 넣어짐. HEAD는 현재 사용중인 브랜치에 위치.

git status			:: 현재 인덱스/커밋의 상태를 확인. 
			:: 저장소의 상태를 확인하기 위해 사용.
			:: 현재 브랜치의 이름과 추가/변경된 파일 및 디렉토리 목록 표시.
git log			:: 로컬 저장소의 commit 히스토리 확인.
git remote add origin "url"	:: 원격 저장소(url)의 정보를 추가. url은 github같은경우엔 실제 그냥 url사용하는듯. origin은 사용 이유가 있음. 위에 정리해 놓았음.
git remote [-v]		:: 현재 저장된 원격 저장소의 목록 표시 -v추가시 자세한 목록.
git remote remove[rm] "name" :: 원격 저장소 제거.
git branch 		:: 현재 브랜치 목록. 현재 branch에는 *이 붙음.
git branch "이름"		:: 새로운 브랜치 생성
git checkout "브랜치이름"	:: 해당 브랜치로 브랜치전환
git checkout - b "브랜치이름"	:: 해당 브랜치를 생성하고 동시에 브랜치 전환.
git branch -d "브랜치이름"	:: 해당 브랜치 삭제
git merge "브랜치이름"	:: 현재 브랜치에서 해당 브랜치 병합
git pull origin "브랜치이름"	:: 로컬 저장소로 원격 저장소 해당 브랜치의 작업 다운/업데이트
? 로컬 저장소의 브랜치와 원격 저장소의 브랜치가 다른가..?
+ add/commit부분은 해당 브랜치에 업데이트 되는 것.
git grep "검색단어"		:: 저장소의 파일 내용에서 검색하고자 할 때 사용하는 명령어.
			:: 특정 단어가 포함 된 파일을 검색하고, 해당 파일의 어디에 단어가
			::포함되어 있는지를 확인 가능.
			:: --> 로컬 저장소.
git clone "url"		:: 기존 원격 저장소를 로컬에 다운로드하기 위해 사용.
git reset 			:: 로컬 저장소의 커밋을 취소하기 위해서 사용하는 명령어.
			:: 잘못된 커밋 혹은 수정의 누락시 사용. (ex. git reset -soft HEAD^)
git reset --hard HEAD~ 	:: 마지막으로 진행했던 병합 명령을 취소...한다는데
			:: 이건 나중에 직접 써봐야 알 듯.
rebase
https://backlog.com/git-tutorial/kr/stepup/stepup2_8.html

! github repository를 생성하고, 원격저장소로 사용하기 위해서 새로운 파일 작성 후에 git add로 뭐 로컬저장소로 올리고.. commit시키고 push시키면 뙇 하고 
Updates were rejected because the remote contains work that you do not have locally라는 에러가 발생함.
이 에러는 github repositoy를 생성할 때 readme파일을 생성했기 때문임
이를 해결하기 위해서는 github의 원격레포지토리를 로컬로 불러와서(fetch) 합쳐야함(merge)

! Updates were rejected because the tip of your current branch is behind its remote counterpart.
이거 역시 원격 저장소의 변경사항을 pull시키고 병합해줘야하고.. push해줘야한다는 것 때문이라는데
왜안될가...
--> git pull origin master --allow-unrelated-histories
이미 존재하는 두 프로젝트의 기록(history)을 저장하는 드문 상황에 사용된다고함.
git에서는 서로 관련 기록이 없는 이질적인 두 프로젝트를 병합할 때 기본적으로 거부하지만, 이것을 허용해줌.
어디서는 이걸 조심해야되며, 사용하지 말것을 권유하는데...
github의 원격저장소와 로컬저장소를 연결하는게 이거말고는 답이 없는데....
https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories-on-rebase/37938036#37938036


현상의 발생 원인 / 영향 및 피해에 대한 평가 / 문제를 즉각적으로 해결하기 위한 활동 내용 / 같은 문제의 재발 방지를 위한 활동 내용 / 배운점 등.

pull		:: 원격 저장소의 내용을 가져와 자동으로 병합 작업을 실행.
fetch		:: 단순히 원격 저장소의 내용만을 가져와 확인. 로컬저장소와 병합은 하기 싫을 때.
		:: 원격 저장소의 최신 커밋 이력을 로컬의 이름없는 브랜치로 가져옴.
		:: 원격 저장소의 내용을 로컬 저장소에 통합하고 싶을 때에는 merge혹은 pull.
pull은 내부적으로 fetch+merge
push하지 않는다면 원격저장소에 영향을 주지 않고 자신만의 브랜치에서 자유롭게 작업이 가능.

tag
- 커밋을 참조하기 쉽도록 알기 쉬운 이름을 붙이는 것.
- 한번 붙이 태그는 브랜치처럼 이동하지 않고 고정됨.
- 일반태그		:: 이름만 붙일 수 있음.
- 주석태그		:: 이름은 물론, 태그에 대한 설명, 서명, 만든사람, 이메일, 날짜등도 포함이 가능.
보통 릴리스 브랜치에서는 주석태그를, 토픽 브랜치에서는 일반태그를 사용함.

git tag <tagname>		:: 태그 추가.
git tag apple		:: 현재 'HEAD'가 가리키고 있는 커밋에 'apple'이라는 태그를 달음.
git tag			:: 태그 목록 확인
git tag -n			:: 태그 목록 및 주석 내용 확인
git tag -d <tagname>	:: 해당 이름의 태그 삭제
git log --decorate		:: 커밋 이력을 확인, 이때, 태그 정보를 포함한 이력을 확인 할 수 있음.
git tag -a <tagname>	:: 주석달린 태그 추가. m옵션을 통해 바로 내용 작성이 가능함.

Commit수정.
같은 브랜치 상에서 이전에 커밋했던 내용에 새로운 내용을 추가하거나 설명을 수정할 수 있음.
revert명령어를 통해 특정 커밋의 내용을 삭제할 수 있음.
rebase -i 혹은 reset명령어를 통해서도 삭제가 가능하지만, 커밋이 공개된 상태에서는 삭제 작업이 힘겨움.
revert의 경우에는 특정 커밋의 내용을 지우는 새로운 커밋을 만들어 안전하게 처리가 가능함.
A-B-C-B'의 순서인데 약간 B'를 B를 지운 커밋이라고 하는데..
약간 순서가 덮어씌우는 형식인듯.
A. A의 커밋.
A-B A의 내용에 B의 내용을 추가한 커밋.
A-B-C A의 내용에 B의 내용을 추가하고 다시 C를 추가한 커밋.
A-B-C-B' B의 내용을 제거하여 A와 C의 내용만 있는 커밋...이런느낌인가

reset.
더 이상 필요없어진 커밋들을 버릴 수 있음.
이때, 명령어를 통해 어떤 모드로 실행할지, HEAD의 위치와 인덱스, 작업트리내용을 되돌릴지의 여부를 설정가능.
--> 특정 버전으로 다시 되돌아 가능 것.
모드의 default는 mixed.
mixed는 인덱스는 변경하고 작업트리의 내용은 변경하지 않음. 세가지 모드가 모두 HEAD의 위치가 변경됨.
soft와 hard를 지정이 가능함.
soft는 인덱스와 작업트리 모두 변경하지 않으며,
hard는 인덱스와 작업트리 모두 변경함.

soft 	:: 커밋만 되돌리고 싶을 때.
mixed	:: 변경한 인덱스의 상태를 원래대로 되돌리고 싶을 때
hard	:: 최근의 커밋을 완전히 버리고 이전의 상태로 되돌리고 싶을 때.

커밋/인덱스/작업트리에 대한 개념이 잡혀있어야 될듯.
커밋은 어디에 종속되는거지?

cherry-pick을 사용하면다른 브랜치에서 지정한 커밋을 복사하여 현재 브랜치로 가져올 수 있음.
원래 의도와는 다른 브랜치에 잘못 추가한 커밋을 올바른 브랜치로 옮기려고 할 때 사용 가능.

rebasi -i명령 시에는 커밋을 다시 쓰거나 다른 커밋과 바꿔 넣을 수 있으며, 특정 위치의 커밋을 삭제하거나 여러 커밋을 하나로 통합하는 작업이 가능함.
물론 다시쓰거나 바꿔넣거나 할 때에는 그 뒤의 커밋 내용도 바뀜.

merge --> squash
--squash옵션을 사용하여 브랜치를 병합하면, 해당 브랜치의 커밋 전체를 통합한 커밋이 추가됨.

git commit --amend		:: 커밋과 동시에 작성할 커밋 메시지를 지정하게 함.
			:: 메시지를 지정 할 편집기가 열리며, 해당 내용의 확인은 
			:: git log명령어를 통해 커밋 내용을 확인 가능함.
			:: 편집기 내용 추가(a)로 주석여부는 모르겠는데, 주석을 제거하고 커밋을 추가하였음.

뭔가 이상하네. HEAD가 뭔가 안맞는거 같아서 revert했더니 분명 1111~4444까지 커밋시켰는데 1111,2222만 존재했었음.
그래서 파일에 3333을 추가하고 내용을 작성한채로 git commit --amend했는데...
이전 커밋내용에 추가된 느낌이랄까...
아 ㅋㅋ 뭔가 이상해서 다시 commit도 시켜보고 좀 했는데 원격 저장소랑 안맞다고 pull시키라는데...
일단 pull해야겠네..
pull시키니 커밋간에 오류?가 발생.
약간 뭐랄까.. 충돌이 발생.
수정후 일단 push해놓음.
음...

일단 revert와 --amend는 완료
commit이력을 남겨놓고 --amend를 통해 이전 커밋 메시지를 수정해보았었음.
그후 revert를 통해 수정된 커밋을 제거한, 그 이전의 커밋으로 이동하였음.
git commit --amend
git revert HEAD

아...
브랜치를 만들어서 temp라는 파일에는 5555까지, 기존 master브랜치에는 6666까지 추가하였음.
master브랜치에는 6666까지, temp1브랜치에는 5555까지 하나의 파일에서
브랜치의 변경만으로 파일의 내용이 달라짐.
이때, 따로 만들어놓기만 하고 add를 하지 않았거나 했을경우에는 공유되는데...?
오....
최초 한번의 commit으로 업데이트 하기 전에는 해당 파일에 대해서 모든 브런치가 공유함.
브랜치에서 커밋할 경우에는 해당 브랜치를 제외한 다른 브랜치에서는 해당 파일이 사라짐.
그 전까지는 변경을 공유하는 듯.

git reset --hard HEAD~~ 	:: HEAD로부터 HEAD포함 두개의 커밋을 삭제
git reset --hard HEAD~ 	:: HEAD로부터 HEAD포함 한개의 커밋을 삭제... == git reset --hard HEAD?
위 명령어에서 HEAD와 HEAD~의 동작은 좀 다른거같은데...ㅣㄴ

HEAD는 git log상에서는 동일한거같긴한데...
그냥 HEAD할경우에는 커밋이 안지워지는거같은데..
아 그냥 동작을 안하는듯
언제든 pull 을 하면 FETCH_HEAD가 뜨넹
그냥 HEAD시에는 안되는거같고
HEAD~시에는 한개의 커밋이 삭제되는 듯.
+  reset전의 커밋은 ORIG_HEAD로 참조가 가능함.
+ 잘못 reset했을 때, git  reset --hard ORIG_HEAD시에 해당 커밋 삭제 이전으로 다시 복구?가 가능해짐.

cherry-pick.
master브랜치에서 temp1 branch의 커밋이력을 master브랜치에 병합할 때
git checkout temp1
git log	// 통합시킬 커밋의 코드(?) 복사
git checkout master
git cherry-pick '커밋코드'

애매하다고 해야되나...pull로 해당 커밋이력을 통합시켰을 때
추가된 파일?이라고 하면 뭔가 추가가 되겠는데
그이후에 pull로 원격저장소의 내용을 가져왔을때, 오류없이 성공이 되었었음.
그렇다면 추가했던 add(나의 경우 add)파일이 사라져야 정상인거같은데 사라지지는 않고...
혹시나 해서 확인해보니 git 원격 저장소에도 남아있고...
git push origin master를 통해서 등록할때에도 오류가 따로 뜨진않고 원격 저장소에 등록 되었음.
일단, cherry-pick시에도 파일의 충돌시에는 수정을 해 주어야 함.

커밋의 통합
rebase -i 명령어를 통해 가능함.
git rebase -i HEAD~~ 를 통해 HEAD부터 HEAD~~까지의 커밋이력을 통합 가능함.
이때, 명시된 Commands를 사용하여 어떤식으로 사용할지 명시해 주는듯?
rebase -i 에서 edit햇을 경우엔
커밋을 수정하고 
git reabse --continue를 통해 커밋 작업을 종료했음을 알려야 함.
중지하고자 할 때에는 git rebase --abort
rebase전의 상태로 되돌릴 때에도 git reset --hard ORIG_HEAD

git checkout master
git merge --squash temp1
temp1브랜치의 모든 커밋을 하나로 통합하여 master브랜치에 통합

하나의 파일을 만들고 첫번째 커밋에는 1111, 두번째는 2222, 세번째는 3333이라는 글을 추가하여 커밋하였음.



이후는 날잡고 지옥에서 온 git으로.









